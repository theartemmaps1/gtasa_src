
/////////////////////////////////////////////////////////////////////////////////
//
// FILE :    PointLights.cpp
// PURPOSE : Deals with pointlights. These are being generated by things in the
//			 game (streetlights etc) and being used to render cars/peds later on.
//			 Basically they have to be stored temporarily..
// AUTHOR :  Obbe.
// CREATED : 8/8/00
//
//	16/03/2001	- Andrzej:	- fix for gpPointlightRaster;
//	26/11/2002	- Andrzej:	- CVuTurboSprite{} functionality added;
//
//
//
//
//
//
/////////////////////////////////////////////////////////////////////////////////

#include "PointLights.h"
#include "setup.h"
#include "lights.h"
#include "camera.h"
#include "coronas.h"
#include "sprite.h"
#include "timer.h"
#include "weather.h"
#include "colpoint.h"
#include "world.h"
#include "CutsceneMgr.h"
#include "handy.h"
#include "main.h"
#include "general.h"

#ifdef GTA_PS2
	#define USE_VU_TURBO_SPRITE
#endif


#ifdef USE_VU_TURBO_SPRITE
	#include "VuTurboSprite.h"

	//
	// for compatibility with RW std Im2D pipeline:
	//
	#define TS_INTENSITY(I)			(I)			//(I>>1)
#endif




Int32					CPointLights::NumLights;
CRegisteredPointLight	CPointLights::aLights[MAX_POINT_LIGHTS];

CVector					CPointLights::aCachedMapReads[MAX_CACHED_MAP_READS];
float					CPointLights::aCachedMapReadResults[MAX_CACHED_MAP_READS];
Int32					CPointLights::NextCachedValue = 0;


// defined and loaded in "Particles.cpp":				
extern RwRaster		*gpPointlightRaster;
								

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION : Init
// PURPOSE :
/////////////////////////////////////////////////////////////////////////////////

void CPointLights::Init()
{
	Int32	C;
	
	for (C = 0; C < MAX_CACHED_MAP_READS; C++)
	{
		aCachedMapReads[C] = CVector(0.0f, 0.0f, 0.0f);
		aCachedMapReadResults[C] = 0.0f;
		NextCachedValue = 0;
	}
}


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION : AddLight
// PURPOSE :  Adds one light to the list to be used whilst rendering
/////////////////////////////////////////////////////////////////////////////////

#define MAX_DIST_POINT_LIGHT (15.0f)	// Maximum distance to the camera where thingy still gets taken into account

void CPointLights::AddLight(UInt8 Type, CVector Coors, CVector Dir, float Range, float Red, float Green, float Blue, UInt8 FogEffect, bool bCastsShadowFromPlayerCarAndPed, CEntity *pArgCastingEntity)
{
	float	DiffX, DiffY, Distance, Mult;
	// Test the distance to the camera
	DiffX = Coors.x - TheCamera.GetPosition().x;
	if (DiffX < (MAX_DIST_POINT_LIGHT + Range))
	{
		if (DiffX > -(MAX_DIST_POINT_LIGHT + Range))
		{
			DiffY = Coors.y - TheCamera.GetPosition().y;
			if (DiffY < (MAX_DIST_POINT_LIGHT + Range))
			{
				if (DiffY > -(MAX_DIST_POINT_LIGHT + Range))
				{
					if (NumLights < MAX_POINT_LIGHTS)
					{
						Distance = CMaths::Sqrt(DiffX*DiffX + DiffY*DiffY + (Coors.z - TheCamera.GetPosition().z)*(Coors.z - TheCamera.GetPosition().z));
						if (Distance < (MAX_DIST_POINT_LIGHT + Range))
						{
							aLights[NumLights].Type = Type;
							aLights[NumLights].FogEffect = FogEffect;
							aLights[NumLights].Coors = Coors;
							aLights[NumLights].Dir = Dir;
							aLights[NumLights].Range = Range;
							aLights[NumLights].bCastsShadowFromPlayerCarAndPed = bCastsShadowFromPlayerCarAndPed;
							aLights[NumLights].pCastingEntity = pArgCastingEntity;
							if (Distance < 0.75f*(MAX_DIST_POINT_LIGHT + Range))
							{
								aLights[NumLights].Red = Red;
								aLights[NumLights].Green = Green;
								aLights[NumLights].Blue = Blue;
							}
							else
							{
								Mult = 1.0f - ((Distance / (MAX_DIST_POINT_LIGHT + Range)) - 0.75f) * 4.0f;
								aLights[NumLights].Red = Red * Mult;
								aLights[NumLights].Green = Green * Mult;
								aLights[NumLights].Blue = Blue * Mult;
							}
							NumLights++;
						}
					}
				}
			}
		}
	}

}// end of CPointLights::AddLight()...



/////////////////////////////////////////////////////////////////////////////////
// FUNCTION : GenerateLightsAffectingObject
// PURPOSE :  Giving the coordinates of this object we generate the directional lights
//			  that affect it.
//			  returns the light multiplier (1.0 most of the time) This is because of the
//			  antilights.
/////////////////////////////////////////////////////////////////////////////////

float CPointLights::GenerateLightsAffectingObject(const CVector *pCoors, float *pPointLightsTotal, CEntity *pEntity)
{
	float	DeltaX, DeltaY, DeltaZ, Range, Distance, Multiplier;
	float	DirX, DirY, DirZ, RDistance, DotPr, LightMult = 1.0f, DistScaled;
	Int16	Light;
	
	// Go through the lights
	for (Light = 0; Light < NumLights; Light++)
	{
		if (aLights[Light].Type != PLTYPE_ONLYFOGEFFECT_ALWAYS && aLights[Light].Type != PLTYPE_ONLYFOGEFFECT)
		{
			Range = aLights[Light].Range;
			DeltaX = aLights[Light].Coors.x - pCoors->x;
			if (DeltaX > -Range)
			{
				if (DeltaX < Range)
				{
					DeltaY = aLights[Light].Coors.y - pCoors->y;
					if (DeltaY > -Range)
					{
						if (DeltaY < Range)
						{
							DeltaZ = aLights[Light].Coors.z - pCoors->z;
							if (DeltaZ > -Range)
							{
								if (DeltaZ < Range)
								{
										// Within range. Calculate distance
									Distance = CMaths::Sqrt(DeltaX*DeltaX + DeltaY*DeltaY + DeltaZ*DeltaZ);
									if (Distance < Range)
									{
										if (aLights[Light].Type == PLTYPE_ANTILIGHT)
										{
											LightMult = CMaths::MultNorm(LightMult, (Distance / Range)); 
										}
										else
										{
											DistScaled = Distance / Range;
											// save these point light values for ai use
											if(pPointLightsTotal)
											{
												Multiplier = 1.0f - DistScaled;
												
												const float inv3 = 1.0f / 3.0f;
												*pPointLightsTotal += CMaths::NormalizeMultErr(aLights[Light].Red	* Multiplier * inv3);
												*pPointLightsTotal += CMaths::NormalizeMultErr(aLights[Light].Green * Multiplier * inv3);
												*pPointLightsTotal += CMaths::NormalizeMultErr(aLights[Light].Blue	* Multiplier * inv3);
											}
									
											if (DistScaled < 0.5f)
											{
												Multiplier = 1.0f;
											}
											else
											{
												Multiplier = 1.0f - 2.0f * (DistScaled - 0.5f);
											}
											if (Distance != 0.0f)
											{
												RDistance = 1.0f / Distance;
												DirX = CMaths::MultNorm(DeltaX, RDistance);
												DirY = CMaths::MultNorm(DeltaY, RDistance);
												DirZ = CMaths::MultNorm(DeltaZ, RDistance);
		
												// Directional lights get their intensity decreased depending
												// on how far away from the direction light the object is.
												if (aLights[Light].Type == PLTYPE_DIRECTIONAL && aLights[Light].pCastingEntity != pEntity)
												{
													DotPr = -(CMaths::MultNorm(DirX, aLights[Light].Dir.x) + CMaths::MultNorm(DirY,aLights[Light].Dir.y) + CMaths::MultNorm(DirZ,aLights[Light].Dir.z));
													Multiplier = CMaths::MultNorm(Multiplier, CMaths::Max(0.0f, CMaths::MultNorm((DotPr-0.5f),2.0f)));
												}

												// Construct this light and add it to the world for this guy
												if (Multiplier > 0.0f)
												{
													AddAnExtraDirectionalLight(Scene.world, DirX, DirY, DirZ, 
															CMaths::MultNorm(aLights[Light].Red,	Multiplier), 
															CMaths::MultNorm(aLights[Light].Green,	Multiplier), 
															CMaths::MultNorm(aLights[Light].Blue,	Multiplier)	);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return (LightMult);

}// end of CPointLights::GenerateLightsAffectingObject()...



//
// name:		GetLightMultiplier
// description:	Get light multiplier based on the lights in an area
float CPointLights::GetLightMultiplier(const CVector *pCoors)//, float fBaseLight)
{
	float DeltaX, DeltaY, DeltaZ;
	float Range, Multiplier;
	float Distance, DistScaled;
	float lightMult=1.0f;
	float lightTotal=0.0f;
	Int16 Light;
	
	// Go through the lights
	for (Light = 0; Light < NumLights; Light++)
	{
		if (aLights[Light].Type != PLTYPE_ONLYFOGEFFECT_ALWAYS && aLights[Light].Type != PLTYPE_ONLYFOGEFFECT)
		{
			Range = aLights[Light].Range;
			DeltaX = aLights[Light].Coors.x - pCoors->x;
			if (DeltaX > -Range)
			{
				if (DeltaX < Range)
				{
					DeltaY = aLights[Light].Coors.y - pCoors->y;
					if (DeltaY > -Range)
					{
						if (DeltaY < Range)
						{
							DeltaZ = aLights[Light].Coors.z - pCoors->z;
							if (DeltaZ > -Range)
							{
								if (DeltaZ < Range)
								{
									// Within range. Calculate distance
									Distance = CMaths::Sqrt(DeltaX*DeltaX + DeltaY*DeltaY + DeltaZ*DeltaZ);
									if (Distance < Range)
									{
										DistScaled = Distance / Range;
// aaron says we can ignore anti-lights for now
// otherwise we would have to store another float in CPed
										if (aLights[Light].Type == PLTYPE_ANTILIGHT)
										{
											//fBaseLight *= DistScaled;
											lightMult = CMaths::MultNorm(lightMult, DistScaled);
										}
										else
										{
											Multiplier = 1.0f - DistScaled;
											
											const float inv3 = 1.0f / 3.0f;	
											lightTotal += CMaths::NormalizeMultErr(aLights[Light].Red	* Multiplier * inv3);
											lightTotal += CMaths::NormalizeMultErr(aLights[Light].Green * Multiplier * inv3);
											lightTotal += CMaths::NormalizeMultErr(aLights[Light].Blue	* Multiplier * inv3);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	//return bBaseLight + lightTotal;
	return lightMult + lightTotal;

}// end of CPointLights::GenerateLightsAffectingObject()...





/////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION : RemoveLightsAffectingObject
// PURPOSE :  Removes them.
//
/////////////////////////////////////////////////////////////////////////////////

void CPointLights::RemoveLightsAffectingObject()
{
	RemoveExtraDirectionalLights(Scene.world);
}




/////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION : RenderFogEffect
// PURPOSE :  Render cool sprites.
//
/////////////////////////////////////////////////////////////////////////////////
#define EFFECTSIZEFRONT 			(12.0f)	// 20 metres should do
#define EFFECTSIZESIDE  			(5.0f)	// 4 metres either side
#define EFFECTSTEP					(4)			// How many metres apart are the dots
#define EFFECTSTEPNONDIRLIGHTS		(2)			// How many metres apart are the dots
#define EFFECTSTEPSMOG				(6)			// How many metres apart are the dots
//#define EFFECTSTEPZ				(2)			// How many metres apart are the dots
//#define EFFECTSIZERADIUS			(9.0f)	// for non-directional lights
static float FogSizes[8] = 			{ 1.3f, 2.0f, 1.7f, 2.0f, 1.4f, 2.1f, 1.5f, 2.3f };

extern RwTexture			*gpCloudTex[2];	// textures for clouds (clouds.cpp)


void CPointLights::RenderFogEffect()
{


	// MN - removed as texture is no longer loaded 
	// this is because the old particle stuff is no longer in


	CVector		EndPoint, ScreenCoors;
	float		MinX, MaxX, MinY, MaxY;//, MinZ, MaxZ;
	float		RelX, RelY, RelZ, Dot, I, Dist;
	float		LengthRelSqr, LengthSideSqr, LengthRel;
	float		CamDist;
	float		OurFoggyness;
	CColPoint	TestColPoint;
	CEntity*	TestEntity;


uint32 	decreaseFogTexBanding 	= 0;		// to remove ugly texture "interpolation banding" effect on PS2
float	EFFECTSIZERADIUS		= 9.0f;		// for non-directional lights 


	// seems to slow down with very low FOVs
	if(CCutsceneMgr::IsCutsceneRunning())
		return;

	RwRenderStateSet(rwRENDERSTATEFOGENABLE,		(void *)FALSE);

    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE,		(void*)FALSE);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE,		(void*)TRUE);

    // Additive blending please
    // get the old render states
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE,(void*)TRUE);

    // New states for additive alpha
    RwRenderStateSet(rwRENDERSTATESRCBLEND,			(void*)rwBLENDONE);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND,		(void*)rwBLENDONE);
	RwRenderStateSet(rwRENDERSTATETEXTURERASTER,	RwTextureGetRaster(gpCloudTex[0]));

	#if defined(USE_VU_TURBO_SPRITE) && defined(GTA_PS2)
		const float CONST_FOV_SCALE = 70.0f / CDraw::GetFOV();
	// Oblong sprites don't seem to work with the new turbosprite code. Use square sprites for now.
//		const float tsScaleX = SCREEN_WIDTH	* CONST_FOV_SCALE;
		const float tsScaleX = SCREEN_HEIGHT* CONST_FOV_SCALE;
		const float tsScaleY = SCREEN_HEIGHT* CONST_FOV_SCALE;

		CVuTurboSprite::InitSpriteBuffer();
	#else
		CSprite::InitSpriteBuffer();
	#endif

	// Go through the lights
	for(int32 Light=0; Light<NumLights; Light++)
	{	
		if (aLights[Light].FogEffect == FOGEFF_ON || aLights[Light].FogEffect == FOGEFF_ALWAYS)
		{
			if (aLights[Light].FogEffect == FOGEFF_ON)
			{
				// outdoor streetlight:
				OurFoggyness			= CWeather::Foggyness;
				decreaseFogTexBanding 	= 0;	// not necessary for outdoor lights (texture banding not that visible)
				EFFECTSIZERADIUS 		= 9.0f;
			}
			else
			{
				// indoor light (bar, club, etc):
				OurFoggyness			= 0.4f; // Emergency measure to tone fog down in clubs. Set back to 1.0f after SA
				decreaseFogTexBanding	= 16;	// to remove ugly texture "interpolation banding" effect on PS2 (vertex colors can't be too low, otherwise you will get ugly textures!!!)
				EFFECTSIZERADIUS		= 3.0f;
			}

			if (OurFoggyness != 0.0f)
			{
				if (aLights[Light].Type == PLTYPE_DIRECTIONAL)
				{		// render extravagant fog effect.
						// First we have to find the bounding box.
					

					EndPoint = aLights[Light].Coors + (aLights[Light].Dir * EFFECTSIZEFRONT);
					if (EndPoint.x < aLights[Light].Coors.x)
					{
						MinX = EndPoint.x;
						MaxX = aLights[Light].Coors.x;
					}
					else
					{
						MinX = aLights[Light].Coors.x;
						MaxX = EndPoint.x;			
					}
					if (EndPoint.y < aLights[Light].Coors.y)
					{
						MinY = EndPoint.y;
						MaxY = aLights[Light].Coors.y;
					}
					else
					{
						MinY = aLights[Light].Coors.y;
						MaxY = EndPoint.y;			
					}
						// Use a certain margin (this should be improved)
					MinX -= EFFECTSIZESIDE;
					MaxX += EFFECTSIZESIDE;
					MinY -= EFFECTSIZESIDE;
					MaxY += EFFECTSIZESIDE;
		
					// Go through all the points
					for(int32 LoopX = ((Int16)MinX) - (((Int16)MinX) % EFFECTSTEP); LoopX <= ((Int16)MaxX)+EFFECTSTEP; LoopX+=EFFECTSTEP)
					{
						for(int32 LoopY = ((Int16)MinY) - (((Int16)MinY) % EFFECTSTEP); LoopY <= ((Int16)MaxY)+EFFECTSTEP; LoopY+=EFFECTSTEP)
						{	
		//					for (LoopZ = ((Int16)MinZ) - (((Int16)MinZ) % EFFECTSTEPZ); LoopZ <= ((Int16)MaxZ)+EFFECTSTEPZ; LoopZ+=EFFECTSTEPZ)
		//					{
								Int16 RandomKey = ((LoopX>>2) ^ (LoopY>>2)) & 15;
		
								if (RandomKey & 1)
								{
									RandomKey = RandomKey >> 1;
									// Find the brightness of this point in the beam of the light.
									RelX = LoopX - aLights[Light].Coors.x;
									RelY = LoopY - aLights[Light].Coors.y;
									Dot = RelX * aLights[Light].Dir.x + RelY * aLights[Light].Dir.y;
									if (Dot > 0.0f && Dot < EFFECTSIZEFRONT)		// Only the ones in front of the camera
									{
										// Find out how far points are to the side (of the dir line)
										LengthRelSqr = RelX*RelX + RelY*RelY;
										LengthSideSqr = LengthRelSqr - Dot*Dot;
									
										if (LengthSideSqr < (EFFECTSIZESIDE*EFFECTSIZESIDE))
										{
											// Work out the z coordinate of this one by reading the map (EXPENSIVE)
											CVector	WorldCoors(LoopX, LoopY, aLights[Light].Coors.z + 10.0f);
											if (CWorld::ProcessVerticalLine(WorldCoors, WorldCoors.z - 20.0f, TestColPoint, TestEntity, true, false, false, false))
											{
												WorldCoors.z = TestColPoint.GetPosition().z + 1.3f;				
											
												// Now that we have the z coordinate we can work out the brightness of the point.
												RelX = LoopX - aLights[Light].Coors.x;
												RelY = LoopY - aLights[Light].Coors.y;
												RelZ = WorldCoors.z - aLights[Light].Coors.z;
												Dot = RelX * aLights[Light].Dir.x + RelY * aLights[Light].Dir.y + RelZ * aLights[Light].Dir.z;
												if (Dot > 0.0f && Dot < EFFECTSIZEFRONT)		// Only the ones in front of the camera
												{
													// Find out how far points are to the side (of the dir line)
													LengthRelSqr = RelX*RelX + RelY*RelY + RelZ*RelZ;
													LengthSideSqr = LengthRelSqr - Dot*Dot;
									
													if (LengthSideSqr < (EFFECTSIZESIDE*EFFECTSIZESIDE))
													{
														// Work out the intensity of this point.
														// Take angle into account. (Bright close to central line)
														LengthRel = CMaths::Sqrt(LengthRelSqr);
														I = 50.0f * OurFoggyness * Dot / LengthRel;	// was 158.
														// Take distance from headlights in to account. (Bright close up)
														I *= 1.0f - (Dot / EFFECTSIZEFRONT)*(Dot / EFFECTSIZEFRONT);
														// Take distance to the side into account
														I *= 1.0f - (CMaths::Sqrt(LengthSideSqr) / EFFECTSIZESIDE) * (CMaths::Sqrt(LengthSideSqr) / EFFECTSIZESIDE);

														#if defined(USE_VU_TURBO_SPRITE) && defined(GTA_PS2)
															const CVector WorldCoors(LoopX, LoopY, WorldCoors.z);
															CVuTurboSprite::RenderBufferedOneXLUSprite_Rotate_Aspect(WorldCoors,
																				FogSizes[RandomKey] * tsScaleX *1.0f, FogSizes[RandomKey] * tsScaleY *1.0f,
																				(I*aLights[Light].Red), (I*aLights[Light].Green), (I*aLights[Light].Blue), TS_INTENSITY((Int16)I),
																				(CTimer::GetTimeInMilliseconds() & 8191) * (6.28 / 8192.0f) );
														#else
															float ScaleX, ScaleY;
															if (CSprite::CalcScreenCoors(CVector(LoopX, LoopY, WorldCoors.z), &ScreenCoors, &ScaleX, &ScaleY))
															{
								    							const float RecipZ = 1.0f / ScreenCoors.z;
																CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect(ScreenCoors.x, ScreenCoors.y, ScreenCoors.z,
																				FogSizes[RandomKey] * ScaleX *1.0f, FogSizes[RandomKey] * ScaleY *1.0f,
																				(I*aLights[Light].Red), (I*aLights[Light].Green), (I*aLights[Light].Blue), (Int16)I, RecipZ,
																				(CTimer::GetTimeInMilliseconds() & 8191) * (6.28 / 8192.0f) );
															}
														#endif
													}
												}
											}
										}
									}
								}
		//					}
						}
					}
				}
				else if (aLights[Light].Type == PLTYPE_POINTLIGHT || aLights[Light].Type == PLTYPE_ONLYFOGEFFECT || aLights[Light].Type == PLTYPE_ONLYFOGEFFECT_ALWAYS)
				{		// render extravagant fog effect.
					// Only do one read map.
//					if (CWorld::ProcessVerticalLine(aLights[Light].Coors, aLights[Light].Coors.z - 20.0f, TestColPoint, TestEntity, true, false, false, false))
					float	ZVal;
					if (ProcessVerticalLineUsingCache(aLights[Light].Coors, &ZVal))
					{
						MinX = aLights[Light].Coors.x - EFFECTSIZERADIUS;
						MaxX = aLights[Light].Coors.x + EFFECTSIZERADIUS;
						MinY = aLights[Light].Coors.y - EFFECTSIZERADIUS;
						MaxY = aLights[Light].Coors.y + EFFECTSIZERADIUS;
		
						for(int32 LoopX = ((Int16)MinX) - (((Int16)MinX) % EFFECTSTEPNONDIRLIGHTS); LoopX <= ((Int16)MaxX)+EFFECTSTEPNONDIRLIGHTS; LoopX+=EFFECTSTEPNONDIRLIGHTS)
						{
							for(int32 LoopY = ((Int16)MinY) - (((Int16)MinY) % EFFECTSTEPNONDIRLIGHTS); LoopY <= ((Int16)MaxY)+EFFECTSTEPNONDIRLIGHTS; LoopY+=EFFECTSTEPNONDIRLIGHTS)
							{
								Int16 RandomKey = ((LoopX/EFFECTSTEPNONDIRLIGHTS) ^ (LoopY/EFFECTSTEPNONDIRLIGHTS)) & 15;
		
								if (RandomKey & 1)
								{
									RandomKey = RandomKey >> 1;
							
									Dist = CMaths::Sqrt( (LoopX - aLights[Light].Coors.x) * (LoopX - aLights[Light].Coors.x) + (LoopY - aLights[Light].Coors.y) * (LoopY - aLights[Light].Coors.y));
									if (Dist < EFFECTSIZERADIUS)
									{
										CamDist = CMaths::Sqrt((LoopX - TheCamera.GetPosition().x)*(LoopX - TheCamera.GetPosition().x) + (LoopY - TheCamera.GetPosition().y)*(LoopY - TheCamera.GetPosition().y));
										if (CamDist < MAX_DIST_POINT_LIGHT)
										{
											if (CamDist < (MAX_DIST_POINT_LIGHT * 2 / 4))
											{
												I = 1.0f;
											}
											else
											{
												I = 1.0f - (CamDist - (MAX_DIST_POINT_LIGHT * 2 / 4)) / (MAX_DIST_POINT_LIGHT / 2);
											}
											
											I *= 37.0f /*45.0f*/ * OurFoggyness * (1.0f - (Dist / EFFECTSIZERADIUS)*(Dist / EFFECTSIZERADIUS));

											#if defined(USE_VU_TURBO_SPRITE) && defined(GTA_PS2)
												const CVector WorldCoors(LoopX, LoopY, ZVal + 1.6f);
												CVuTurboSprite::RenderBufferedOneXLUSprite_Rotate_Aspect(WorldCoors,
															FogSizes[RandomKey] * tsScaleX, FogSizes[RandomKey] * tsScaleY /** 0.7f*/,
															(UInt8)(I*aLights[Light].Red+decreaseFogTexBanding), (UInt8)(I*aLights[Light].Green+decreaseFogTexBanding), (UInt8)(I*aLights[Light].Blue+decreaseFogTexBanding), TS_INTENSITY((Int16)255),
															((CTimer::GetTimeInMilliseconds() + RandomKey * 2300) & 32767) * (6.28 / 32768.0f));
											#else
												float ScaleX, ScaleY;
												if(CSprite::CalcScreenCoors(CVector(LoopX, LoopY, ZVal + 1.6f), &ScreenCoors, &ScaleX, &ScaleY))
												{
								    				const float RecipZ = 1.0f / ScreenCoors.z;
													CSprite::RenderBufferedOneXLUSprite_Rotate_Aspect(ScreenCoors.x, ScreenCoors.y, ScreenCoors.z,
																FogSizes[RandomKey] * ScaleX, FogSizes[RandomKey] * ScaleY * 0.7f,
																(UInt8)(I*aLights[Light].Red), (UInt8)(I*aLights[Light].Green), (UInt8)(I*aLights[Light].Blue), (Int16)I, RecipZ,
																((CTimer::GetTimeInMilliseconds() + RandomKey * 2300) & 32767) * (6.28 / 32768.0f));
												}
											#endif
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}//	for(int32 Light=0; Light<NumLights; Light++)..


	#if defined(USE_VU_TURBO_SPRITE) && defined(GTA_PS2)
		CVuTurboSprite::FlushSpriteBuffer();
	#else
		CSprite::FlushSpriteBuffer();
	#endif


    // Restore original blend modes
//  RwRenderStateSet(rwRENDERSTATESRCBLEND,  (void *)srcBlend);
//  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (void *)dstBlend);
//  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (void*)FALSE);
//  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE,      (void *)TRUE);
//  RwRenderStateSet(rwRENDERSTATEZTESTENABLE,       (void *)TRUE);

}// end of CPointLights::RenderFogEffect()...


/*
void CPointLights::RenderSmogEffect()
{
	float		MinX, MaxX, MinY, MaxY;
	float		CamDist, I, Dist;
	float		ZVal, angle;
	float		OurFoggyness = 2.0f;
		
	// seems to slow down with very low FOVs
	if(CCutsceneMgr::IsCutsceneRunning())
		return;
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE,		(void*)TRUE);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE,		(void*)FALSE);

    // Additive blending please
    // get the old render states
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE,(void*)TRUE);

    // New states for additive alpha
    RwRenderStateSet(rwRENDERSTATESRCBLEND,			(void*)rwBLENDONE);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND,		(void*)rwBLENDSRCALPHA);
	RwRenderStateSet(rwRENDERSTATETEXTURERASTER,	gpPointlightRaster);
	
	
	#ifdef USE_VU_TURBO_SPRITE
		const float CONST_FOV_SCALE = 70.0f / CDraw::GetFOV();
		const float tsScaleX = SCREEN_WIDTH	* CONST_FOV_SCALE * 7.5f;
		const float tsScaleY = SCREEN_HEIGHT* CONST_FOV_SCALE * 7.5f;

		CVuTurboSprite::InitSpriteBuffer();
	#else
		CSprite::InitSpriteBuffer();
	#endif

	for(int32 Light=0; Light<NumLights; Light++)
	{	
		if (aLights[Light].Type == PLTYPE_SMOG)
		{
			MinX = aLights[Light].Coors.x - EFFECTSIZERADIUS * 4.0f;
			MaxX = aLights[Light].Coors.x + EFFECTSIZERADIUS * 4.0f;
			MinY = aLights[Light].Coors.y - EFFECTSIZERADIUS * 4.0f;
			MaxY = aLights[Light].Coors.y + EFFECTSIZERADIUS * 4.0f;
			ZVal = aLights[Light].Coors.z;
			angle = (CTimer::GetTimeInMilliseconds() & 16383) * (3.14f / 16384.0f);
			for(int32 LoopX = ((Int16)MinX) - (((Int16)MinX) % EFFECTSTEPSMOG); LoopX <= ((Int16)MaxX)+EFFECTSTEPSMOG; LoopX+=EFFECTSTEPSMOG)
			{
				for(int32 LoopY = ((Int16)MinY) - (((Int16)MinY) % EFFECTSTEPSMOG); LoopY <= ((Int16)MaxY)+EFFECTSTEPSMOG; LoopY+=EFFECTSTEPSMOG)
				{
					Int16 RandomKey = ((LoopX/EFFECTSTEPSMOG) ^ (LoopY/EFFECTSTEPSMOG)) & 15;

					if (RandomKey & 1)
					{
						RandomKey = RandomKey >> 1;
				
						Dist = CMaths::Sqrt( (LoopX - aLights[Light].Coors.x) * (LoopX - aLights[Light].Coors.x) + (LoopY - aLights[Light].Coors.y) * (LoopY - aLights[Light].Coors.y));
						if (Dist < EFFECTSIZERADIUS * 4.0f)
						{
							CamDist = CMaths::Sqrt((LoopX - TheCamera.GetPosition().x)*(LoopX - TheCamera.GetPosition().x) + (LoopY - TheCamera.GetPosition().y)*(LoopY - TheCamera.GetPosition().y));
							if (CamDist > MAX_DIST_POINT_LIGHT)
							{
								I = 132.0f * OurFoggyness * (Dist * 0.25f/ EFFECTSIZERADIUS)*(Dist * 0.25f / EFFECTSIZERADIUS);
							
								#ifdef USE_VU_TURBO_SPRITE
									const CVector WorldCoors(LoopX, LoopY, ZVal);
									CVuTurboSprite::RenderBufferedOneXLUSprite_Rotate_Dimension(WorldCoors,
												FogSizes[RandomKey] * tsScaleX, FogSizes[RandomKey] * tsScaleY,
												(UInt8)(aLights[Light].Red), (UInt8)(aLights[Light].Green), (UInt8)(aLights[Light].Blue), TS_INTENSITY((Int16)I),
												angle);
								#else
									float ScaleX, ScaleY;
									if(CSprite::CalcScreenCoors(CVector(LoopX, LoopY, ZVal), &ScreenCoors, &ScaleX, &ScaleY))
									{
					    				const float RecipZ = 1.0f / ScreenCoors.z;
										CSprite::RenderBufferedOneXLUSprite_Rotate_Dimension(ScreenCoors.x, ScreenCoors.y, ScreenCoors.z,
													FogSizes[RandomKey] * ScaleX, FogSizes[RandomKey] * ScaleY,
													(UInt8)(I*aLights[Light].Red), (UInt8)(I*aLights[Light].Green), (UInt8)(I*aLights[Light].Blue), (Int16)I, RecipZ,
													angle);
									}
								#endif
							}
						}
					}
				}

			}
		}
	}	
	#ifdef USE_VU_TURBO_SPRITE
		CVuTurboSprite::FlushSpriteBuffer();
	#else
		CSprite::FlushSpriteBuffer();
	#endif

}
*/

//
//
//
//
bool CPointLights::ProcessVerticalLineUsingCache(CVector Coors, float *pResult)
{
	
	for(int32 C=0; C<MAX_CACHED_MAP_READS; C++)
	{
		if (aCachedMapReads[C] == Coors)
		{
			*pResult = aCachedMapReadResults[C];
			return true;
		}
	}


	CColPoint	TestColPoint;
	CEntity*	TestEntity;

	// Couldn't find cached value. Read again.
	if (CWorld::ProcessVerticalLine(Coors, Coors.z - 20.0f, TestColPoint, TestEntity, true, false, false, false))
	{
		aCachedMapReads[NextCachedValue] = Coors;
		aCachedMapReadResults[NextCachedValue] = TestColPoint.GetPosition().z;
		NextCachedValue = (NextCachedValue+1) % MAX_CACHED_MAP_READS;
		*pResult = TestColPoint.GetPosition().z;
		
		return(TRUE);
	}
	
	return(FALSE);
}











/* Old version without height reading
/////////////////////////////////////////////////////////////////////////////////
// FUNCTION : RenderFogEffect
// PURPOSE :  Render cool sprites.
/////////////////////////////////////////////////////////////////////////////////
#define EFFECTSIZEFRONT (12.0f)	// 20 metres should do
#define EFFECTSIZESIDE  (5.0f)	// 4 metres either side
#define EFFECTSTEP		(4)			// How many metres apart are the dots
#define EFFECTSTEPZ		(2)			// How many metres apart are the dots
float	FogSizes[8] = { 1.3f, 2.0f, 1.3f, 2.0f, 1.0f, 2.5f, 1.5f, 2.5f };


void CPointLights::RenderFogEffect()
{
	Int16		Light;
	CVector		EndPoint, ScreenCoors;
	float		MinX, MaxX, MinY, MaxY, MinZ, MaxZ;
	float		ScaleX, ScaleY, RecipZ;
	float		RelX, RelY, RelZ, Dot, I;
	float		LengthRelSqr, LengthSideSqr, LengthRel;
	Int16		LoopX, LoopY, LoopZ;
	Int16		RandomKey;
   	RwInt32 	srcBlend, dstBlend;


if ( !(CTimer::GetTimeInMilliseconds() & (4096 | 2048))) return;

	if (CWeather::Foggyness == 0.0f) return;	// There has to be fog for it to work

    RwRenderStateSet(rwRENDERSTATEALPHAPRIMITIVEBUFFER, (void *)TRUE);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (void *)FALSE);
    // Additive blending please
    // get the old render states
    RwRenderStateGet(rwRENDERSTATESRCBLEND, &srcBlend);
    RwRenderStateGet(rwRENDERSTATEDESTBLEND, &dstBlend);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (void*)TRUE);

    // New states for additive alpha
    RwRenderStateSet(rwRENDERSTATESRCBLEND, (void *)rwBLENDONE);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (void *)rwBLENDONE);
 

	RwRenderStateSet(rwRENDERSTATETEXTURERASTER, gpCoronaRaster[1]);
	
	// Go through the lights
	for (Light = 0; Light < NumLights; Light++)
	{
		if (aLights[Light].Type == PLTYPE_DIRECTIONAL)
		{		// render extravagant fog effect.
				// First we have to find the bounding box.
			EndPoint = aLights[Light].Coors + (aLights[Light].Dir * EFFECTSIZEFRONT);
			if (EndPoint.x < aLights[Light].Coors.x)
			{
				MinX = EndPoint.x;
				MaxX = aLights[Light].Coors.x;
			}
			else
			{
				MinX = aLights[Light].Coors.x;
				MaxX = EndPoint.x;			
			}
			if (EndPoint.y < aLights[Light].Coors.y)
			{
				MinY = EndPoint.y;
				MaxY = aLights[Light].Coors.y;
			}
			else
			{
				MinY = aLights[Light].Coors.y;
				MaxY = EndPoint.y;			
			}
			if (EndPoint.z < aLights[Light].Coors.z)
			{
				MinZ = EndPoint.z;
				MaxZ = aLights[Light].Coors.z;
			}
			else
			{
				MinZ = aLights[Light].Coors.z;
				MaxZ = EndPoint.z;			
			}
				// Use a certain margin (this should be improved)
			MinX -= EFFECTSIZESIDE;
			MaxX += EFFECTSIZESIDE;
			MinY -= EFFECTSIZESIDE;
			MaxY += EFFECTSIZESIDE;
			MinZ -= EFFECTSIZESIDE;
			MaxZ += EFFECTSIZESIDE;

				// Go through all the points in the cube
			for (LoopX = ((Int16)MinX) - (((Int16)MinX) % EFFECTSTEP); LoopX <= ((Int16)MaxX)+EFFECTSTEP; LoopX+=EFFECTSTEP)
			{
				for (LoopY = ((Int16)MinY) - (((Int16)MinY) % EFFECTSTEP); LoopY <= ((Int16)MaxY)+EFFECTSTEP; LoopY+=EFFECTSTEP)
				{	
					for (LoopZ = ((Int16)MinZ) - (((Int16)MinZ) % EFFECTSTEPZ); LoopZ <= ((Int16)MaxZ)+EFFECTSTEPZ; LoopZ+=EFFECTSTEPZ)
					{
						// Find the brightness of this point in the beam of the light.
						RelX = LoopX - aLights[Light].Coors.x;
						RelY = LoopY - aLights[Light].Coors.y;
						RelZ = LoopZ - aLights[Light].Coors.z;
						Dot = RelX * aLights[Light].Dir.x + RelY * aLights[Light].Dir.y + RelZ * aLights[Light].Dir.z;
						if (Dot > 0.0f && Dot < EFFECTSIZEFRONT)		// Only the ones in front of the camera
						{
							// Find out how far points are to the side (of the dir line)
							LengthRelSqr = RelX*RelX + RelY*RelY + RelZ*RelZ;
							LengthSideSqr = LengthRelSqr - Dot*Dot;
							
							if (LengthSideSqr < (EFFECTSIZESIDE*EFFECTSIZESIDE))
							{
							
								// Work out the intensity of this point.
								// Take angle into account. (Bright close to central line)
								LengthRel = CMaths::Sqrt(LengthRelSqr);
								I = 158.0f * CWeather::Foggyness * Dot / LengthRel;
								// Take distance from headlights in to account. (Bright close up)
								I *= 1.0f - (Dot / EFFECTSIZEFRONT)*(Dot / EFFECTSIZEFRONT);
								// Take distance to the side into account
								I *= 1.0f - (CMaths::Sqrt(LengthSideSqr) / EFFECTSIZESIDE) * (CMaths::Sqrt(LengthSideSqr) / EFFECTSIZESIDE);

								RandomKey = ((LoopX>>2) ^ (LoopY>>2) ^ (LoopZ>>1)) & 7;

								if (RandomKey & 1)
								{
									if (CSprite::CalcScreenCoors(CVector(LoopX, LoopY, LoopZ), &ScreenCoors, &ScaleX, &ScaleY))
									{
					    				RecipZ = 1.0f / ScreenCoors.z;
					    			
//					    			I = 64.0f;

										CSprite::RenderOneXLUSprite(ScreenCoors.x, ScreenCoors.y, ScreenCoors.z,
																	FogSizes[RandomKey] * ScaleX, FogSizes[RandomKey] * ScaleY,
																	(UInt8)I, (UInt8)I, (UInt8)I, (Int16)I, RecipZ );
									}
								}
							}
						}
					}
				}
			}
		}
	}

    // Restore original blend modes
    RwRenderStateSet(rwRENDERSTATESRCBLEND,  (void *)srcBlend);
    RwRenderStateSet(rwRENDERSTATEDESTBLEND, (void *)dstBlend);
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (void*)FALSE);
    RwRenderStateSet(rwRENDERSTATEZWRITEENABLE,      (void *)TRUE);
    RwRenderStateSet(rwRENDERSTATEZTESTENABLE,           (void *)TRUE);

}
*/
